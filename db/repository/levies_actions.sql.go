// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.27.0
// source: levies_actions.sql

package db

import (
	"context"
	"time"
)

const createLevyAction = `-- name: CreateLevyAction :exec
INSERT INTO levies_actions (
   levy_id,
   origin_sector,
   target_sector, 
   action_type,
   completed, 
   expected_completion_at
) VALUES (
    $1, $2, $3, $4, $5, $6
) RETURNING levy_action_id, levy_id, origin_sector, target_sector, action_type, completed, expected_completion_at, created_at
`

type CreateLevyActionParams struct {
	LevyID               int64     `json:"levy_id"`
	OriginSector         int32     `json:"origin_sector"`
	TargetSector         int32     `json:"target_sector"`
	ActionType           string    `json:"action_type"`
	Completed            bool      `json:"completed"`
	ExpectedCompletionAt time.Time `json:"expected_completion_at"`
}

func (q *Queries) CreateLevyAction(ctx context.Context, arg *CreateLevyActionParams) error {
	_, err := q.db.ExecContext(ctx, createLevyAction,
		arg.LevyID,
		arg.OriginSector,
		arg.TargetSector,
		arg.ActionType,
		arg.Completed,
		arg.ExpectedCompletionAt,
	)
	return err
}

const findLevyAction = `-- name: FindLevyAction :one
SELECT levy_action_id, levy_id, origin_sector, target_sector, action_type, completed, expected_completion_at, created_at FROM levies_actions
WHERE levy_action_id = $1 AND action_type = $2
`

type FindLevyActionParams struct {
	LevyActionID int64  `json:"levy_action_id"`
	ActionType   string `json:"action_type"`
}

func (q *Queries) FindLevyAction(ctx context.Context, arg *FindLevyActionParams) (*LeviesAction, error) {
	row := q.db.QueryRowContext(ctx, findLevyAction, arg.LevyActionID, arg.ActionType)
	var i LeviesAction
	err := row.Scan(
		&i.LevyActionID,
		&i.LevyID,
		&i.OriginSector,
		&i.TargetSector,
		&i.ActionType,
		&i.Completed,
		&i.ExpectedCompletionAt,
		&i.CreatedAt,
	)
	return &i, err
}

const findLevyActionCountByLevyId = `-- name: FindLevyActionCountByLevyId :one
SELECT COUNT(*) FROM levies_actions
WHERE levy_id = $1::bigint AND expected_completion_at < $2::timestamptz
LIMIT 1
`

type FindLevyActionCountByLevyIdParams struct {
	LevyID        int64     `json:"levy_id"`
	ReferenceDate time.Time `json:"reference_date"`
}

func (q *Queries) FindLevyActionCountByLevyId(ctx context.Context, arg *FindLevyActionCountByLevyIdParams) (int64, error) {
	row := q.db.QueryRowContext(ctx, findLevyActionCountByLevyId, arg.LevyID, arg.ReferenceDate)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const findTargetLevyActionsSortedByDateForUpdate = `-- name: FindTargetLevyActionsSortedByDateForUpdate :many
SELECT la.levy_action_id, la.levy_id, la.origin_sector, la.target_sector, la.action_type, la.completed, la.expected_completion_at, la.created_at, l.levy_id, l.stationed, l.name, l.morale, l.encampment, l.swordmen, l.shield_bearers, l.archers, l.lancers, l.supply_troop, l.movement_speed, l.realm_member_id, l.realm_id, l.created_at FROM levies_actions AS LA
LEFT JOIN levies AS L
ON LA.levy_id = L.levy_id
WHERE LA.target_sector = $1::int 
AND LA.expected_completion_at < $2::timestamptz
AND LA.completed = false
ORDER BY LA.expected_completion_at ASC
FOR UPDATE OF levies_actions, levies
`

type FindTargetLevyActionsSortedByDateForUpdateParams struct {
	Targetsectorid       int32     `json:"targetsectorid"`
	Expectedcompletionat time.Time `json:"expectedcompletionat"`
}

type FindTargetLevyActionsSortedByDateForUpdateRow struct {
	LeviesAction LeviesAction `json:"levies_action"`
	Levy         Levy         `json:"levy"`
}

func (q *Queries) FindTargetLevyActionsSortedByDateForUpdate(ctx context.Context, arg *FindTargetLevyActionsSortedByDateForUpdateParams) ([]*FindTargetLevyActionsSortedByDateForUpdateRow, error) {
	rows, err := q.db.QueryContext(ctx, findTargetLevyActionsSortedByDateForUpdate, arg.Targetsectorid, arg.Expectedcompletionat)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*FindTargetLevyActionsSortedByDateForUpdateRow{}
	for rows.Next() {
		var i FindTargetLevyActionsSortedByDateForUpdateRow
		if err := rows.Scan(
			&i.LeviesAction.LevyActionID,
			&i.LeviesAction.LevyID,
			&i.LeviesAction.OriginSector,
			&i.LeviesAction.TargetSector,
			&i.LeviesAction.ActionType,
			&i.LeviesAction.Completed,
			&i.LeviesAction.ExpectedCompletionAt,
			&i.LeviesAction.CreatedAt,
			&i.Levy.LevyID,
			&i.Levy.Stationed,
			&i.Levy.Name,
			&i.Levy.Morale,
			&i.Levy.Encampment,
			&i.Levy.Swordmen,
			&i.Levy.ShieldBearers,
			&i.Levy.Archers,
			&i.Levy.Lancers,
			&i.Levy.SupplyTroop,
			&i.Levy.MovementSpeed,
			&i.Levy.RealmMemberID,
			&i.Levy.RealmID,
			&i.Levy.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateLevyActionCompleted = `-- name: UpdateLevyActionCompleted :exec
UPDATE levies_actions
SET completed = $2
WHERE levy_action_id = $1
`

type UpdateLevyActionCompletedParams struct {
	LevyActionID int64 `json:"levy_action_id"`
	Completed    bool  `json:"completed"`
}

func (q *Queries) UpdateLevyActionCompleted(ctx context.Context, arg *UpdateLevyActionCompletedParams) error {
	_, err := q.db.ExecContext(ctx, updateLevyActionCompleted, arg.LevyActionID, arg.Completed)
	return err
}
