// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.27.0
// source: levies_actions.sql

package db

import (
	"context"
	"database/sql"
	"time"
)

const createLevyAction = `-- name: CreateLevyAction :one
INSERT INTO levies_actions (
   levy_id,
   realm_id,
   rm_id,
   origin_sector,
   target_sector, 
   distance,
   action_type,
   completed, 
   started_at,
   expected_completion_at
) VALUES (
    $1, $2, $3, $4, $5, $6, $7, $8, $9, $10
) RETURNING levy_action_id, levy_id, realm_id, rm_id, origin_sector, target_sector, distance, action_type, completed, target_realm_id, started_at, expected_completion_at, created_at
`

type CreateLevyActionParams struct {
	LevyID               int64     `json:"levy_id"`
	RealmID              int64     `json:"realm_id"`
	RmID                 int64     `json:"rm_id"`
	OriginSector         int32     `json:"origin_sector"`
	TargetSector         int32     `json:"target_sector"`
	Distance             float64   `json:"distance"`
	ActionType           string    `json:"action_type"`
	Completed            bool      `json:"completed"`
	StartedAt            time.Time `json:"started_at"`
	ExpectedCompletionAt time.Time `json:"expected_completion_at"`
}

func (q *Queries) CreateLevyAction(ctx context.Context, arg *CreateLevyActionParams) (*LeviesAction, error) {
	row := q.db.QueryRowContext(ctx, createLevyAction,
		arg.LevyID,
		arg.RealmID,
		arg.RmID,
		arg.OriginSector,
		arg.TargetSector,
		arg.Distance,
		arg.ActionType,
		arg.Completed,
		arg.StartedAt,
		arg.ExpectedCompletionAt,
	)
	var i LeviesAction
	err := row.Scan(
		&i.LevyActionID,
		&i.LevyID,
		&i.RealmID,
		&i.RmID,
		&i.OriginSector,
		&i.TargetSector,
		&i.Distance,
		&i.ActionType,
		&i.Completed,
		&i.TargetRealmID,
		&i.StartedAt,
		&i.ExpectedCompletionAt,
		&i.CreatedAt,
	)
	return &i, err
}

const findLevyAction = `-- name: FindLevyAction :one
SELECT levy_action_id, levy_id, realm_id, rm_id, origin_sector, target_sector, distance, action_type, completed, target_realm_id, started_at, expected_completion_at, created_at FROM levies_actions
WHERE levy_action_id = $1
LIMIT 1
`

func (q *Queries) FindLevyAction(ctx context.Context, levyActionID int64) (*LeviesAction, error) {
	row := q.db.QueryRowContext(ctx, findLevyAction, levyActionID)
	var i LeviesAction
	err := row.Scan(
		&i.LevyActionID,
		&i.LevyID,
		&i.RealmID,
		&i.RmID,
		&i.OriginSector,
		&i.TargetSector,
		&i.Distance,
		&i.ActionType,
		&i.Completed,
		&i.TargetRealmID,
		&i.StartedAt,
		&i.ExpectedCompletionAt,
		&i.CreatedAt,
	)
	return &i, err
}

const findLevyActionByLevyId = `-- name: FindLevyActionByLevyId :one
SELECT levy_action_id, levy_id, realm_id, rm_id, origin_sector, target_sector, distance, action_type, completed, target_realm_id, started_at, expected_completion_at, created_at FROM levies_actions
WHERE levy_id = $1 AND completed = false
LIMIT 1
`

func (q *Queries) FindLevyActionByLevyId(ctx context.Context, levyID int64) (*LeviesAction, error) {
	row := q.db.QueryRowContext(ctx, findLevyActionByLevyId, levyID)
	var i LeviesAction
	err := row.Scan(
		&i.LevyActionID,
		&i.LevyID,
		&i.RealmID,
		&i.RmID,
		&i.OriginSector,
		&i.TargetSector,
		&i.Distance,
		&i.ActionType,
		&i.Completed,
		&i.TargetRealmID,
		&i.StartedAt,
		&i.ExpectedCompletionAt,
		&i.CreatedAt,
	)
	return &i, err
}

const findLevyActionCountByLevyId = `-- name: FindLevyActionCountByLevyId :one
SELECT COUNT(*) FROM levies_actions
WHERE levy_id = $1::bigint 
AND expected_completion_at < $2::timestamptz
AND completed = false
LIMIT 1
`

type FindLevyActionCountByLevyIdParams struct {
	LevyID        int64     `json:"levy_id"`
	ReferenceDate time.Time `json:"reference_date"`
}

func (q *Queries) FindLevyActionCountByLevyId(ctx context.Context, arg *FindLevyActionCountByLevyIdParams) (int64, error) {
	row := q.db.QueryRowContext(ctx, findLevyActionCountByLevyId, arg.LevyID, arg.ReferenceDate)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const findLevyActionsBeforeDate = `-- name: FindLevyActionsBeforeDate :many
SELECT l.levy_id, l.stationed, l.name, l.morale, l.encampment, l.swordmen, l.shield_bearers, l.archers, l.lancers, l.supply_troop, l.movement_speed, l.rm_id, l.realm_id, l.created_at, la.levy_action_id, la.levy_id, la.realm_id, la.rm_id, la.origin_sector, la.target_sector, la.distance, la.action_type, la.completed, la.target_realm_id, la.started_at, la.expected_completion_at, la.created_at FROM levies_actions AS LA
LEFT JOIN levies AS L
ON LA.levy_id = L.levy_id
WHERE LA.expected_completion_at <= $1::timestamptz
AND LA.completed = false
ORDER BY LA.expected_completion_at ASC
`

type FindLevyActionsBeforeDateRow struct {
	Levy         Levy         `json:"levy"`
	LeviesAction LeviesAction `json:"levies_action"`
}

func (q *Queries) FindLevyActionsBeforeDate(ctx context.Context, currentWorldTime time.Time) ([]*FindLevyActionsBeforeDateRow, error) {
	rows, err := q.db.QueryContext(ctx, findLevyActionsBeforeDate, currentWorldTime)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*FindLevyActionsBeforeDateRow{}
	for rows.Next() {
		var i FindLevyActionsBeforeDateRow
		if err := rows.Scan(
			&i.Levy.LevyID,
			&i.Levy.Stationed,
			&i.Levy.Name,
			&i.Levy.Morale,
			&i.Levy.Encampment,
			&i.Levy.Swordmen,
			&i.Levy.ShieldBearers,
			&i.Levy.Archers,
			&i.Levy.Lancers,
			&i.Levy.SupplyTroop,
			&i.Levy.MovementSpeed,
			&i.Levy.RmID,
			&i.Levy.RealmID,
			&i.Levy.CreatedAt,
			&i.LeviesAction.LevyActionID,
			&i.LeviesAction.LevyID,
			&i.LeviesAction.RealmID,
			&i.LeviesAction.RmID,
			&i.LeviesAction.OriginSector,
			&i.LeviesAction.TargetSector,
			&i.LeviesAction.Distance,
			&i.LeviesAction.ActionType,
			&i.LeviesAction.Completed,
			&i.LeviesAction.TargetRealmID,
			&i.LeviesAction.StartedAt,
			&i.LeviesAction.ExpectedCompletionAt,
			&i.LeviesAction.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const findOnGoingMyRealmActions = `-- name: FindOnGoingMyRealmActions :many
SELECT levy_action_id, levy_id, realm_id, rm_id, origin_sector, target_sector, distance, action_type, completed, target_realm_id, started_at, expected_completion_at, created_at FROM levies_actions
WHERE realm_id = $1 AND completed = false
`

func (q *Queries) FindOnGoingMyRealmActions(ctx context.Context, realmID int64) ([]*LeviesAction, error) {
	rows, err := q.db.QueryContext(ctx, findOnGoingMyRealmActions, realmID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*LeviesAction{}
	for rows.Next() {
		var i LeviesAction
		if err := rows.Scan(
			&i.LevyActionID,
			&i.LevyID,
			&i.RealmID,
			&i.RmID,
			&i.OriginSector,
			&i.TargetSector,
			&i.Distance,
			&i.ActionType,
			&i.Completed,
			&i.TargetRealmID,
			&i.StartedAt,
			&i.ExpectedCompletionAt,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateLevyActionCompleted = `-- name: UpdateLevyActionCompleted :exec
UPDATE levies_actions
SET completed = $2,
target_realm_id = $3
WHERE levy_action_id = $1
`

type UpdateLevyActionCompletedParams struct {
	LevyActionID  int64         `json:"levy_action_id"`
	Completed     bool          `json:"completed"`
	TargetRealmID sql.NullInt64 `json:"target_realm_id"`
}

func (q *Queries) UpdateLevyActionCompleted(ctx context.Context, arg *UpdateLevyActionCompletedParams) error {
	_, err := q.db.ExecContext(ctx, updateLevyActionCompleted, arg.LevyActionID, arg.Completed, arg.TargetRealmID)
	return err
}
